# DeepClone项目设计草稿  

<br/>

## 项目需求

以Natasha为动态构建引擎，编写一个深度克隆的组件，提供类与结构体的深度克隆。
要有完整的UT测试，从广度，到深度。

<br/>
<br/>


## 技术难点

 - ### 类型识别：
 
   - OnceType(简单类型)：
    
      - 基元类型：即内置类型，例如int,long,float,string等等
      - 特殊类型：decimal
      - 枚举类型：enum  
    

   - 数组类型：
  
      - 一维数组
      - 多维数组
      
   - 集合类型：
 
      - 链表
      - 集合
      - 列表

   - 键值对类型：
 
      - 字典
      - 并发字典
      - KeyAndValue
    
   - 普通实体类  
  
   - 结构体类型
 
      - 自定义结构体
      - 元组  
      
<br/>  

 - ### Readonly字段  
 
       readonly 字段通常由初始化获得，因此我们需要对构造函数进行挑选，并在克隆的时候进行传参处理。  
 
 <br/>  
 
 - ### 属性读写权限
 
       在遍历成员时，需要过滤一下带有特殊读写权限的属性。  
 
  <br/>  
 
 - ### 高效极简操作：
 
       在数组copy时，可以使用ArrayCopy、Memory.Copy、ReadonlySpan等方法,需要调研。  
 
  <br/>  
  
 - ###  Object类型：
 
        Object类型是干扰泛型类型的一个因素，因此是否对Object做支持，如何做，是一个难点。  
        
   <br/>  
  
 
 - ### 类型反解：
 
        在使用Natasha的过程中，需要像写原生代码一样写脚本，但是有些类型的名字在运行时是被处理过的，例如：
 
 typeof(List<int>).Name, 输出的是List~1, 因此我们需要用到Natasha的反解器，type.GetDevelopmentName();  
 
   <br/>  
  
 
 - ### UT测试方法：
 
       请区分好Assert.Same/Equal方法，灵活使用。
 
<br/>
<br/>  

## 成员分工

<br/>
<br/>

## 开发流程

1. 了解需求，分析难点。
1. 确定各自的开发模块。
1. 使用运行时模拟模块的工作代码。
1. 讨论类库架构以及模块的集成方式。
1. 进入开发阶段，代码、注释、单元测试。
1. CodeReview。
1. 补充文档，并文档Review。

<br/>
<br/>

## 后期规划  

深度克隆是熟悉.NET类型的最好实践，有了此基础，便可以做一些更加有难度的事情。例如实体类、结构体快照，实体映射。

<br/>
<br/>
